Jenkins
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
Introduction to Jenkins:
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
	What is Jenkins?
----------------------------------------------------------------------------------------------------------------------
Jenkins 
	open-source automation server 
		used for 
			continuous integration and 
			continuous delivery (CI/CD) of software projects. 
	Provides a platform for 
		building, 
		testing, and 
		deploying applications 
		automating various tasks in the software development lifecycle.

Key features and concepts associated with Jenkins:

    Continuous Integration (CI): 

    Continuous Delivery and Deployment (CD): 
    Jobs and Pipelines: 
		organizes tasks into jobs or pipelines. 
		job 
			single task or action
			e.g. 
				building the code, 
				running tests, or 
				deploying the application. 
		Pipelines
			more flexible and scriptable way to define complex workflows 
			encompass multiple 
				stages, 
				steps, and 
				conditions.

    Plugins and Integrations: 
		Vast ecosystem of plugins 
		Plugins can be installed to 
			integrate with 
				source code repositories (e.g., Git, SVN), 
				build tools (e.g., Maven, Gradle), 
				testing frameworks, 
				deployment tools
					ect.
		These plugins allow 
			customization and 
			integration 
				with other tools 
    Distributed and Scalable: 
		
    Extensibility and Community: 
		users can develop custom plugins and extensions to meet specific requirements. 

Jenkins is widely adopted by development teams and organizations of all sizes due to its flexibility, extensibility, and robust feature set. It helps automate repetitive tasks, streamlines the software delivery process, and enables faster, more reliable releases.
	

----------------------------------------------------------------------------------------------------------------------
	Key features and benefits of Jenkins
----------------------------------------------------------------------------------------------------------------------

key features and benefits of Jenkins:

    Continuous Integration and Delivery (CI/CD): Jenkins enables the practice of CI/CD by automating the build, test, and deployment processes. It allows teams to integrate code changes frequently, detect issues early, and deliver software faster and more reliably.

    Extensive Plugin Ecosystem: Jenkins has a vast collection of plugins that provide integration with various tools and technologies. These plugins enhance Jenkins' capabilities and allow for customization based on specific project requirements.

    Distributed and Scalable: Jenkins supports a distributed architecture, allowing the distribution of workloads across multiple machines. This capability enables parallel execution of jobs, improves performance, and scales with growing project needs.

    Flexibility and Customizability: Jenkins provides flexibility in defining build workflows, test suites, and deployment pipelines. It allows users to customize and configure jobs to fit their specific development and deployment processes.

    Robust Notifications and Reporting: Jenkins offers comprehensive reporting and notification mechanisms. It provides detailed information on build and test results, generates reports, and sends notifications to stakeholders about job statuses, failures, and other events.

    Integration with Source Control and Build Tools: Jenkins integrates seamlessly with popular source control systems like Git, SVN, and others. It also supports a wide range of build tools such as Maven, Gradle, and Ant, allowing users to leverage their existing tools and workflows.

    Security and Access Control: Jenkins offers security features to control access to jobs, manage user permissions, and secure sensitive information. It supports authentication mechanisms like LDAP, Active Directory, and role-based access control (RBAC).

    Active and Supportive Community: Jenkins has a large and active community of users and contributors. The community provides ongoing support, shares best practices, develops new plugins, and regularly updates Jenkins with new features and enhancements.

    Platform Independence: Jenkins is platform-independent and runs on various operating systems like Windows, macOS, Linux, and more. This makes it accessible to developers and teams working on different platforms.

    Open-Source and Cost-Effective: Jenkins is an open-source tool, which means it is freely available and can be customized as needed. This makes it a cost-effective solution for organizations and enables collaboration within the open-source community.

These features and benefits make Jenkins a popular choice for implementing CI/CD pipelines and automating software development and delivery processes. It provides the foundation for efficient and reliable software development practices, allowing teams to accelerate their development cycles and deliver high-quality software.

----------------------------------------------------------------------------------------------------------------------
	Jenkins vs. other automation tools
----------------------------------------------------------------------------------------------------------------------


Jenkins 
compare Jenkins with a few popular alternatives:
    GitLab CI/CD: 
		GitLab CI/CD is a part of the GitLab platform that provides integrated CI/CD capabilities. Unlike Jenkins, which requires separate installation and configuration, GitLab CI/CD is built-in within the GitLab ecosystem. This tight integration offers a seamless experience for managing code repositories, CI/CD pipelines, and project collaboration.

    Travis CI: 
		Travis CI is a cloud-based CI/CD platform primarily used for open-source projects. It simplifies the setup process by providing a hosted environment, eliminating the need for self-hosting infrastructure like Jenkins. Travis CI offers strong integration with GitHub, making it straightforward to trigger builds and deployments upon code changes.

    CircleCI: 
		CircleCI is another cloud-based CI/CD platform that emphasizes simplicity and ease of use. It offers a modern and intuitive user interface, extensive documentation, and straightforward configuration. CircleCI also provides robust support for containers and parallel builds, allowing faster execution of CI/CD pipelines.

    Azure DevOps (formerly Visual Studio Team Services): 
		Azure DevOps is a comprehensive suite of tools for end-to-end software development, including CI/CD capabilities. It provides integration with Azure cloud services and offers a unified platform for managing source control, work tracking, build pipelines, and release management. Azure DevOps is well-suited for organizations heavily invested in the Microsoft ecosystem.

    Bamboo: 
		Bamboo is an alternative to Jenkins offered by Atlassian, the same company behind Jira and Confluence. Bamboo is known for its seamless integration with other Atlassian tools and offers a user-friendly interface. It provides features like build pipelines, artifact management, and deployment automation.

When comparing these tools, it's important to consider factors such as flexibility, extensibility, integration with existing tools, ease of use, scalability, community support, and pricing models. Each tool has its own strengths and may be a better fit depending on the specific needs, preferences, and infrastructure of the organization or development team.

----------------------------------------------------------------------------------------------------------------------
Jenkins Installation and Configuration:
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
	Installing Jenkins on different platforms
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
	Initial setup and configuration
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
	Managing Jenkins plugins
----------------------------------------------------------------------------------------------------------------------
	D:\PraiseTheLord\HSBGInfotech\Others\vilas\devops\jenkins\Lab\Plugins\Jacoco

----------------------------------------------------------------------------------------------------------------------
	Securing Jenkins with authentication and authorization
----------------------------------------------------------------------------------------------------------------------
	D:\PraiseTheLord\HSBGInfotech\Others\vilas\devops\jenkins\Lab\JenkinsUsers

----------------------------------------------------------------------------------------------------------------------
Jenkins Pipeline:
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
	Introduction to Jenkins Pipeline
----------------------------------------------------------------------------------------------------------------------
Declarative and Scripted Syntax: 
	Jenkins Pipeline supports two syntaxes - 
		declarative and scripted. 
		
		declarative syntax 
			more structured and opinionated approach 
			scripted syntax allows for more flexibility and control.

Stage-Based Pipelines: 
	Jenkins Pipeline 
		define your pipeline as a series of stages
		Each stage represents a logical unit of work. 
		Stages can be 
			sequential or parallel
			enabling you to run multiple tasks concurrently.

Reusability: 
	Jenkins Pipeline 
		promotes code reuse 
		allow to define shared libraries 
		encapsulate common pipeline functionality. 
		shared libraries 
			can be used across multiple pipelines
			ensure consistency and 
			reduce duplication.

Integration with Version Control Systems: 
	Jenkins Pipeline 
		integrates with various version control systems
			e.g. Git, BitBucket, SVN, and Mercurial
			allow trigger pipeline runs automatically 
				whenever changes are detected in your source code repository.

Rich Plugin Ecosystem: 
	Jenkins has a vast plugin ecosystem
	Jenkins Pipeline leverages these plugins 
		integrate with a wide range of tools and technologies
		including build tools
		testing frameworks
		deployment platforms, and more.

Visualizations and Reporting: 
	Jenkins Pipeline provides visualization and reporting capabilities 
	help you monitor and analyze the progress and results of your pipelines. 
	It offers a 
		web-based user interface
		logs, and various plugins to generate reports and notifications.



----------------------------------------------------------------------------------------------------------------------
	Creating and managing Jenkins Pipeline jobs
----------------------------------------------------------------------------------------------------------------------
Jenkins pipeline 
	collection of events or jobs 
		generally interlinked 
			to form a workflow.

Combination of plugins 
	support integration and implementation of continuous delivery pipelines using Jenkins.
	Can be used to incorporate 
		continuous delivery in our software development workflow.




JenkinsFile

	Jenkins Pipeline can be defined by a text file called JenkinsFile. 
	Implement pipeline as code using JenkinsFile
	defined by using a DSL (Domain Specific Language). 
	With the help of JenkinsFile, you can write the steps required for running a Jenkins Pipeline.

The benefits of using JenkinsFile are:

    You can make pipelines automatically run for all branches 
		can execute pull requests with just one JenkinsFile.
    You can review your code on the pipeline.
    You can review your Jenkins pipeline.
    This is the singular source for your pipeline and can be customized by multiple users.

JenkinsFile can be defined by using either Web UI or with a JenkinsFile.
Pipeline syntax



----------------------------------------------------------------------------------------------------------------------
	Declarative vs. Scripted Pipeline syntax
----------------------------------------------------------------------------------------------------------------------
Two types of syntax are used for defining your JenkinsFile.

    Declarative
    Scripted
	
Declarative	
	Declarative pipeline syntax offers a simple way to create pipelines. It consists of a predefined hierarchy to create Jenkins pipelines. It provides you the ability to control all aspects of a pipeline execution in a simple, straightforward manner.

Scripted:

Scripted Jenkins pipeline syntax runs on the Jenkins master with the help of a lightweight executor. It uses very few resources to convert the pipeline into atomic commands.

Both scripted and declarative syntax are different from each other and are defined totally differently.

----------------------------------------------------------------------------------------------------------------------
	Defining stages and steps in a Pipeline
----------------------------------------------------------------------------------------------------------------------
https://github.com/vilasvarghese/jenkins-tutorial
----------------------------------------------------------------------------------------------------------------------
	Using Jenkinsfile for Pipeline as code
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
Jenkins Agents and Distributed Builds:
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
	Understanding Jenkins agents (slaves)
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
	Configuring and managing agents in Jenkins
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
	Master-slave architecture and distributed builds
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
	Agent provisioning strategies (static vs. dynamic)
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
Jenkins Job Configuration:
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
	Configuring freestyle jobs in Jenkins
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
	Defining build triggers and schedules
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
	Source code management (SCM) integration
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
	Build environment and execution settings
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
	Post-build actions and result analysis
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
Jenkins Plugins and Integration:
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
	Exploring popular Jenkins plugins
----------------------------------------------------------------------------------------------------------------------

    Pipeline (formerly known as Workflow): 
		This plugin allows users to define complex, scriptable pipelines using the Jenkinsfile. It provides a powerful and flexible way to define CI/CD pipelines as code.

    Git: 
		The Git plugin integrates Jenkins with Git, enabling seamless integration and support for Git-based repositories. It allows cloning, pulling, and pushing code from and to Git repositories and supports advanced features like tagging, submodules, and branch merging.

    Credentials: 
		The Credentials plugin allows the management and usage of credentials in Jenkins, such as usernames, passwords, API tokens, SSH keys, and more. It ensures secure handling and storage of sensitive information.

    Docker: 
		The Docker plugin allows Jenkins to interact with Docker containers and Docker Swarm clusters. It provides functionality to build, deploy, and run Docker containers as part of the CI/CD process.

	etc.

----------------------------------------------------------------------------------------------------------------------
	Integrating Jenkins with version control systems (Git, Bitbucket)
----------------------------------------------------------------------------------------------------------------------

Integrating with Git
	Integrating Jenkins with Git, a popular version control system, allows you to automate your build and deployment processes based on changes in your Git repositories. Here's how you can integrate Jenkins with Git:

	Install Git Plugin: Start by installing the Git Plugin on your Jenkins server. Go to "Manage Jenkins" > "Manage Plugins" > "Available" tab, search for "Git Plugin," and install it.

	Configure Global Git Settings: In the Jenkins web interface, go to "Manage Jenkins" > "Global Tool Configuration." Scroll down to the "Git" section and provide the path to the Git executable. You can either let Jenkins auto-install Git or manually provide the path if Git is already installed on your system.

	Create a New Jenkins Job: Create a new Jenkins job by clicking on "New Item" on the Jenkins homepage. Enter a name for your job and select the job type based on your project requirements (e.g., Freestyle project or Pipeline).

	Configure Source Code Management: In the job configuration page, scroll down to the "Source Code Management" section. Select "Git" as the version control system.

	Specify Repository Details: Provide the Git repository URL in the "Repository URL" field. You can use HTTPS or SSH URLs, depending on your repository's configuration. If authentication is required, you can specify the credentials for accessing the Git repository.

	Branches to Build: Specify the branches to build. You can enter the branch names or use wildcards to match multiple branches. You can also enable the "Poll SCM" option to periodically check for changes in the repository.

	Additional Git Configuration: You can configure additional options like clean workspace, checkout to specific local branch, submodule handling, and more, based on your project requirements.

	Save the Job Configuration: Click "Save" to save the job configuration.

	Trigger the Job: You can trigger the job manually by clicking on the "Build Now" button. Alternatively, you can configure triggers to automatically start the job when changes are detected in the Git repository. For example, you can set up a webhook in your Git repository to notify Jenkins whenever a new commit is pushed.

	Monitor the Job: Once the job is triggered, you can monitor its progress in the job's build history page. Jenkins will clone the Git repository, checkout the specified branch, and perform the defined build steps or execute the pipeline script.

Integrating with Bitbucket

	Integrating Jenkins with Bitbucket, a popular version control system, allows you to automate your build and deployment processes based on changes in your Bitbucket repositories. Here's how you can integrate Jenkins with Bitbucket:

	Install Bitbucket Plugin: Start by installing the Bitbucket Plugin on your Jenkins server. Go to "Manage Jenkins" > "Manage Plugins" > "Available" tab, search for "Bitbucket Plugin," and install it.

	Configure Bitbucket Webhook: In your Bitbucket repository, go to "Settings" > "Webhooks" (or "Hooks" depending on your Bitbucket version). Add a new webhook and specify the following details:

	URL: Provide the Jenkins webhook URL. The format is typically http://<jenkins-server>/bitbucket-hook/.
	Events: Select the events for which you want Bitbucket to trigger the webhook, such as "Repository Push" or "Pull Request Created."
	Save the webhook configuration.
	Configure Bitbucket Credentials in Jenkins: In the Jenkins web interface, go to "Manage Jenkins" > "Manage Credentials." Add a new credential with the following details:

	Kind: Select "Username with password" or "SSH username with private key" based on your Bitbucket authentication method.
	Username: Enter the Bitbucket username or SSH key username.
	Password or Private Key: Enter the corresponding password or private key.
	ID: Assign an ID to the credential for later reference.
	Save the credential configuration.
	Create a New Jenkins Job: Create a new Jenkins job by clicking on "New Item" on the Jenkins homepage. Enter a name for your job and select the job type based on your project requirements (e.g., Freestyle project or Pipeline).

	Configure Source Code Management: In the job configuration page, scroll down to the "Source Code Management" section. Select "Git" as the version control system.

	Specify Repository Details: Provide the Bitbucket repository URL in the "Repository URL" field. Use either HTTPS or SSH URL depending on your repository's configuration.

	Bitbucket Credentials: Click on the "Add" button in the "Credentials" section and select the Bitbucket credential configured in step 3.

	Branches to Build: Specify the branches to build. You can enter the branch names or use wildcards to match multiple branches. You can also enable the "Poll SCM" option to periodically check for changes in the repository.

	Additional Git Configuration: You can configure additional options like clean workspace, checkout to a specific local branch, submodule handling, and more, based on your project requirements.

	Save the Job Configuration: Click "Save" to save the job configuration.

	Trigger the Job: You can trigger the job manually by clicking on the "Build Now" button. Alternatively, whenever changes are pushed to your Bitbucket repository or the specified events are triggered, Bitbucket will send a webhook notification to Jenkins, which will automatically start the job.

	Monitor the Job: Once the job is triggered, you can monitor its progress in the job's build history page. Jenkins will clone the Bitbucket repository, checkout the specified branch, and perform the defined build steps or execute the pipeline script.



----------------------------------------------------------------------------------------------------------------------
	Integrating Jenkins with build tools (Maven, Gradle)
----------------------------------------------------------------------------------------------------------------------
	    Install and Configure Jenkins: Set up Jenkins on your desired server or cloud environment by following the installation instructions provided by the Jenkins documentation.

    Install the Maven Integration Plugin: In Jenkins, go to "Manage Jenkins" -> "Manage Plugins" -> "Available" tab. Search for "Maven Integration Plugin" and install it. This plugin enables Jenkins to work with Maven projects.

    Configure Global Maven Settings: In Jenkins, go to "Manage Jenkins" -> "Global Tool Configuration." Scroll down to the "Maven" section and click on "Add Maven." Provide a name for the Maven installation and specify the path to your Maven installation directory. Save the configuration.

    Create a New Jenkins Job: Navigate to the Jenkins dashboard and click on "New Item" to create a new job. Enter a name for the job and select "Freestyle project" as the job type.

    Configure the Maven Build Step: In the job configuration, under the "Build" section, click on "Add build step" and select "Invoke top-level Maven targets." In the "Goals" field, specify the Maven goals and options you want to execute during the build process. For example, you can use "clean install" to clean the project and build the artifacts.

    Configure Maven Installation: In the same build step configuration, select the Maven installation you configured in step 3 from the "Maven version" dropdown.

    Save the Job Configuration: Once you have configured the Maven build step and any other desired settings for the job, save the job configuration.

    Trigger the Maven Build: On the Jenkins dashboard, locate your newly created job and click on "Build Now" to trigger the Maven build. Jenkins will execute the Maven goals specified in the job configuration and provide detailed logs and reports.

----------------------------------------------------------------------------------------------------------------------
	Integrating Jenkins with deployment tools (Docker)
----------------------------------------------------------------------------------------------------------------------
Refer to my instructions

----------------------------------------------------------------------------------------------------------------------
	Integrating Jenkins with Cloud Formation
----------------------------------------------------------------------------------------------------------------------

	Create an iam role giving ec2 permission to work with cloudformation.
	Attach it to the jenkins ec2 instance.


    Install and Configure Jenkins: Set up Jenkins on your desired server or cloud environment by following the installation instructions provided by the Jenkins documentation.

    Install AWS CLI Plugin: In Jenkins, go to "Manage Jenkins" -> "Manage Plugins" -> "Available" tab. Search for the "AWS CLI Plugin" and install it. This plugin enables Jenkins to interact with AWS services, including CloudFormation.

    Configure AWS Credentials: In Jenkins, go to "Manage Jenkins" -> "Manage Credentials" -> "Global" domain. Add your AWS credentials (Access Key ID and Secret Access Key) as an AWS credentials entry. This allows Jenkins to authenticate with your AWS account.

    Create a New Jenkins Job: Navigate to the Jenkins dashboard and click on "New Item" to create a new job. Enter a name for the job and select "Freestyle project" as the job type.

    Configure Source Code Management: In the job configuration, under the "Source Code Management" section, configure your repository settings, such as Git or SVN, depending on your source code version control system.

    Configure Build Steps: In the job configuration, under the "Build" section, add build steps to build your application or perform any necessary pre-deployment tasks.

    Add AWS CLI Commands: Add build steps using the AWS CLI plugin to interact with AWS services. To work with CloudFormation, you can use AWS CLI commands like aws cloudformation create-stack, aws cloudformation update-stack, aws cloudformation delete-stack, etc. Configure the commands with the necessary CloudFormation template file, stack name, and any additional parameters required for the stack creation or update.

    Save the Job Configuration: Once you have configured the build steps, save the job configuration.

    Trigger the Jenkins Job: On the Jenkins dashboard, locate your newly created job and click on "Build Now" to trigger the Jenkins job. Jenkins will execute the build steps, run the AWS CLI commands, and create, update, or delete CloudFormation stacks as defined in your job configuration.
----------------------------------------------------------------------------------------------------------------------
Jenkins Security and Access Control:
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
	Jenkins security best practices
----------------------------------------------------------------------------------------------------------------------
	Jenkins is a widely used automation server for continuous integration and continuous delivery (CI/CD) pipelines. To ensure the security of your Jenkins installation and its associated processes, you should follow these best practices:

    Keep Jenkins Updated: Regularly update Jenkins to the latest stable version to ensure you have the latest security fixes and patches.

    Secure Jenkins Installation: During the initial setup, secure Jenkins by enabling access controls and setting up authentication. Use strong passwords for admin accounts and consider using SSH keys for authentication.

    Manage Plugins: Only install necessary plugins from trusted sources. Regularly update plugins to their latest versions to avoid security vulnerabilities in older versions.

    Implement Role-Based Access Control (RBAC): Use Jenkins' built-in RBAC or integrate with external authentication providers (e.g., LDAP, Active Directory) to control access to Jenkins features and jobs based on user roles.

    Limit Access Permissions: Grant permissions sparingly and based on the principle of least privilege. Only give users access to the Jenkins resources they need to perform their jobs.

    Secure Jenkins Secrets: Avoid hardcoding sensitive information (e.g., passwords, API keys) in Jenkinsfiles or scripts. Use Jenkins credentials plugin to store and manage secrets securely.

    Enable HTTPS: Configure Jenkins to use HTTPS to encrypt data transmitted between the server and users.

    Disable Anonymous Access: Unless it's explicitly required, disable anonymous access to Jenkins to prevent unauthorized access.

    Audit Trails and Logging: Enable auditing and logging to track user activities and detect suspicious behavior.

    Use Jenkins Agents Securely: If you're using Jenkins agents (also known as slaves), ensure they are properly configured, and agents should have the necessary access restrictions in place.

    Backup and Disaster Recovery: Regularly back up Jenkins configuration and critical data to facilitate disaster recovery in case of any security incidents.

    Monitor Jenkins Environment: Implement monitoring and alerting to detect unusual activity and potential security breaches.

    Implement Job Sandboxing: Use tools like Jenkins' Script Security Plugin to sandbox and control the execution of scripts within Jenkins jobs.

    Regular Security Assessments: Conduct security assessments and penetration testing to identify vulnerabilities and address them promptly.

    Network Segmentation: Consider isolating Jenkins from the public internet if possible and implement network segmentation to reduce the attack surface.

    Follow Security Best Practices for Code: If your Jenkins pipeline involves executing code from repositories, ensure that the code adheres to security best practices and is thoroughly reviewed.

    Avoid Storing Sensitive Data: Do not store sensitive data, such as API keys, in plain text in Jenkins configuration files or environment variables.

    Disable Unused Features: Disable any unused Jenkins features to minimize potential security risks.

By following these best practices, you can enhance the security of your Jenkins installation and make it more resilient to potential security threats. Remember that security is an ongoing process, and regular reviews and updates are essential to maintain a secure Jenkins environment.

----------------------------------------------------------------------------------------------------------------------
	User authentication and authorization
----------------------------------------------------------------------------------------------------------------------

	User authentication and authorization are critical components of any system that aims to protect sensitive information and control access to resources. Let's explore each of these concepts:

User Authentication:
Authentication is the process of verifying the identity of users or entities attempting to access a system or application. It ensures that users are who they claim to be before allowing them access to protected resources. There are several authentication methods, including:

    Username and Password: The most common method where users provide a username and password combination to prove their identity.

    Multi-Factor Authentication (MFA): Requires users to provide multiple forms of identification, such as a password and a one-time code sent to their mobile device.

    Public Key Infrastructure (PKI): Uses digital certificates and private/public key pairs for secure authentication.

    OAuth and OpenID Connect: Protocols commonly used for authentication and authorization in web applications.

    LDAP/Active Directory Integration: Authentication using existing directory services to manage user identities centrally.

    Biometric Authentication: Uses unique biological traits, such as fingerprints or facial recognition, for identity verification.

User Authorization:
Authorization is the process of determining what resources and actions a user is allowed to access or perform within a system after successful authentication. Authorization controls access based on the roles, permissions, and privileges associated with a user's identity. Some common authorization models include:

    Role-Based Access Control (RBAC): Users are assigned roles, and each role has specific permissions. Users inherit permissions based on their assigned roles.

    Attribute-Based Access Control (ABAC): Access decisions are based on attributes associated with users, resources, and the environment.

    Rule-Based Access Control: Access decisions are made based on predefined rules and conditions.

    Discretionary Access Control (DAC): Allows the owner of a resource to control access and permissions for that resource.

    Mandatory Access Control (MAC): Access decisions are made based on system-wide security policies and labels.

    Policy-Based Access Control (PBAC): Uses policies to define access rules and permissions.

Integration of Authentication and Authorization:
Authentication and authorization often work together in a multi-step process:

    Authentication: Users prove their identity through one of the authentication methods mentioned above.

    Authorization: Once authenticated, the system checks the user's identity against the defined access control rules to determine what actions or resources the user is allowed to access.

    Session Management: After successful authentication and authorization, a session is established, allowing the user to access resources without re-authentication until the session expires.

It's important to implement strong authentication and authorization mechanisms to safeguard sensitive data and resources effectively. Regularly reviewing and updating access controls is crucial to maintaining a secure system, especially as user roles and access requirements change over time.

----------------------------------------------------------------------------------------------------------------------
	Role-based access control (RBAC) in Jenkins
----------------------------------------------------------------------------------------------------------------------
devops\jenkins\Lab\JenkinsUsers

----------------------------------------------------------------------------------------------------------------------
	Plugin security considerations
----------------------------------------------------------------------------------------------------------------------

	Plugins are a powerful feature of Jenkins that extend its functionality and enable integration with various tools and services. However, using plugins can also introduce potential security risks to your Jenkins environment. Here are some important security considerations when using Jenkins plugins:

    Only Install Necessary Plugins: Limit the number of installed plugins to the ones you actually need. Each additional plugin increases the attack surface and potential vulnerabilities.

    Keep Plugins Up-to-Date: Regularly update your plugins to the latest stable versions. Plugin updates often include security fixes, so keeping them current helps protect your Jenkins instance from known vulnerabilities.

    Use Plugins from Trusted Sources: Download plugins only from the official Jenkins plugin repository (https://plugins.jenkins.io/) or reputable sources. Avoid downloading plugins from unknown or untrusted websites.

    Check Plugin Compatibility: Ensure that the plugins you are using are compatible with your Jenkins version. Incompatible or outdated plugins may cause security issues or system instability.

    Audit Plugin Permissions: Review the permissions requested by each plugin during installation. Grant permissions sparingly and based on the principle of least privilege.

    Limit Access to Plugin Configuration: Restrict access to plugin configurations and settings to trusted administrators only.

    Enable Security Warnings: Jenkins has a security advisory feature that warns administrators about potential security issues in installed plugins. Enable this feature to receive notifications about vulnerable plugins.

    Disable Unused or Unneeded Plugins: If you no longer use certain plugins, disable or uninstall them. Unused plugins can still pose security risks if they contain vulnerabilities.

    Implement Role-Based Access Control (RBAC): Use Jenkins' built-in RBAC or integrate with external authentication providers to control access to plugin functionality based on user roles.

    Sandboxing and Script Execution: Be cautious when using plugins that execute scripts or interact with external systems. Implement sandboxing and access controls to restrict potential malicious actions.

    Monitor Plugin Activity: Implement monitoring and logging to track plugin activities and detect any suspicious behavior or unauthorized access.

    Perform Security Assessments: Regularly assess the security of your Jenkins environment, including plugins, through penetration testing and vulnerability scanning.

    Backup and Disaster Recovery: Regularly back up your Jenkins configuration and critical data, including plugin configurations, to facilitate disaster recovery in case of security incidents.

    Follow Security Best Practices: When configuring plugins, follow security best practices and guidelines provided by the plugin developers or the Jenkins community.

By following these security considerations, you can help ensure that the use of plugins in your Jenkins environment enhances functionality without compromising the overall security of your CI/CD processes. Remember that plugin security is an ongoing responsibility, and regular updates and reviews are essential to maintaining a secure Jenkins instance.

----------------------------------------------------------------------------------------------------------------------
	Securing Jenkins pipelines
----------------------------------------------------------------------------------------------------------------------

	Securing Jenkins pipelines is crucial to prevent unauthorized access, data breaches, and other security incidents in your CI/CD workflows. Here are some best practices to help secure your Jenkins pipelines:

    Access Control and Authentication:
        Limit access to Jenkins pipelines to authorized users only. Implement strong authentication mechanisms such as username/password, multi-factor authentication (MFA), or integration with LDAP/Active Directory.
        Use role-based access control (RBAC) to grant specific permissions to users based on their roles in the organization.

    Secure Jenkins Credentials:
        Avoid hardcoding sensitive information (e.g., passwords, API keys) directly in Jenkinsfiles or scripts.
        Use Jenkins' built-in credentials plugin to securely store and manage sensitive data. This prevents accidental exposure of credentials in version control systems.

    Pipeline Libraries:
        Consider using shared pipeline libraries to centralize common code and configuration. This helps maintain consistency and ensures that security measures are applied consistently across pipelines.

    Use Agent/Node Isolation:
        Isolate Jenkins agents/nodes based on the jobs they execute. Agents with sensitive access should have restricted network access and run on dedicated machines.

    Script Approval and Sandboxing:
        Enable Jenkins script approval to review and approve any scripts before execution.
        Use Jenkins' Script Security Plugin to sandbox and control the execution of scripts within pipelines.

    Implement Agent/Node Authorization:
        Restrict agent/node access to specific pipeline jobs based on RBAC or other access control mechanisms.

    Code Quality and Security Scanning:
        Integrate code quality and security scanning tools into your pipeline to identify potential vulnerabilities and code issues early in the development process.

    Pipeline Notifications and Logging:
        Set up notifications for pipeline successes, failures, and critical events.
        Implement centralized logging to monitor pipeline activities and detect unusual behavior.

    Secure Jenkins Master:
        Secure the Jenkins master server by restricting network access and using firewalls to limit incoming connections.

    Backup and Recovery:

		Regularly back up your Jenkins server configuration and pipelines to facilitate disaster recovery in case of security incidents or system failures.

    Secure Plugin Usage:

		Ensure that any plugins used in the pipeline are up to date and come from trusted sources.

    Container Security:

		If using containerization, ensure containers are properly configured and hardened to prevent security vulnerabilities.

    Pipeline Validation and Review:

		Regularly review pipeline configurations for security best practices and potential vulnerabilities.

    Secure Environment Variables:

		Avoid exposing sensitive data through environment variables and ensure proper encryption and protection.

    Regular Security Assessments:

		Conduct security assessments and penetration testing to identify vulnerabilities and weaknesses in your Jenkins pipelines.

	By following these best practices, you can enhance the security of your Jenkins pipelines and ensure that your CI/CD processes remain robust and protected from potential security threats.

----------------------------------------------------------------------------------------------------------------------
SCM:
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
• Source Code Management
----------------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------------
• Different type of SCM
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
	Local SCM
----------------------------------------------------------------------------------------------------------------------
	Local Source Code Management (SCM) refers to managing and version controlling source code repositories on a developer's local machine. It involves using a version control system to track changes to the codebase, allowing developers to collaborate, manage changes, and maintain a history of their work. Git is the most widely used version control system for local SCM.

----------------------------------------------------------------------------------------------------------------------
	Centralized SCM
----------------------------------------------------------------------------------------------------------------------

	Centralized Source Code Management (SCM) is a version control approach where all the source code and versioning information is stored in a central repository. In this model, developers check out code from the central repository, work on their changes locally, and then commit those changes back to the central repository. This contrasts with Distributed SCM, like Git, where each developer has their complete repository, and changes can be shared directly between repositories.

Here are the key characteristics and considerations of Centralized SCM:

    Central Repository: The central repository serves as the authoritative source for the project's codebase. It contains the complete version history and is typically hosted on a dedicated server.

    Checkouts and Commits: Developers perform checkouts from the central repository to create a local working copy. They make changes locally and then commit those changes back to the central repository, updating the central version history.

    Lock-Modify-Unlock Model: In some centralized SCMs, such as older versions of CVS (Concurrent Versions System), there may be an optional locking mechanism. It allows only one developer to edit a file at a time, ensuring exclusive access to prevent conflicts.

    Collaboration: Developers collaborate through the central repository, ensuring that all changes are funneled through a single point. This makes it easier to track contributions and maintain a linear history.

    Network Dependency: Developers need network connectivity to interact with the central repository. If the central server goes down or experiences connectivity issues, it can disrupt development workflows.

    Branching and Merging: Centralized SCMs support branching, but merging can sometimes be more challenging and may require extra effort to avoid conflicts.

    Project Governance: In a centralized SCM model, there is usually a designated individual or team responsible for managing the central repository, setting access controls, and overseeing code changes.

Examples of Centralized SCMs include:

    Subversion (SVN): Subversion is a widely used centralized version control system known for its simplicity and ease of use.

    Perforce (Helix Core): Perforce is a commercial centralized SCM often used for large-scale enterprise projects, especially in the gaming and software development industries.

Centralized SCM is a traditional approach to version control that has been used in various software development environments. While it provides a structured workflow and centralized control, it also has some limitations compared to Distributed SCM systems like Git. Distributed SCMs offer more flexibility, support offline work, and allow developers to work more independently, making them increasingly popular in modern software development workflows. However, both models have their strengths and are still used depending on the specific needs of the development team and project.

----------------------------------------------------------------------------------------------------------------------
	Distributed SCM
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
• How Distributed SCM works
----------------------------------------------------------------------------------------------------------------------
Git is a distributed version control system used for tracking changes in source code during software development. It was created by Linus Torvalds in 2005 and has become the most widely used version control system in the world. Git operates on the concept of snapshots and relies on a distributed architecture that allows developers to work independently and collaboratively. Here's how Git works:

    Local Repository:
        Each developer has a local repository on their machine. This repository contains the complete project history, including all files, commits, and branches.

    Working Directory:
        The working directory is where the developer makes changes to the project files. It represents the current state of the codebase.

    Staging Area (Index):
        Before committing changes to the local repository, developers stage their changes in the staging area. This allows them to choose which changes will be included in the next commit.

    Commits:
        A commit in Git represents a snapshot of the project at a particular point in time. It contains information about the changes made, an author, a commit message, and a reference to the parent commit(s).

    Branches:
        Git allows developers to create branches, which are lightweight pointers to a specific commit. Branches make it easy to work on new features or bug fixes without affecting the main codebase.

    Merging:
        Merging combines changes from one branch into another. Git intelligently handles merging by analyzing the changes made in each branch and applying them together.

    Remote Repositories:
        Developers can interact with remote repositories hosted on platforms like GitHub, GitLab, or Bitbucket. Remote repositories serve as a common place for collaboration and sharing code with others.

    Push and Pull:
        To synchronize their work with a remote repository, developers use the push command to send their local commits to the remote repository. Conversely, they use the pull command to fetch changes from the remote repository and update their local copy.

    Forks and Pull Requests:
        In open-source projects, contributors often create forks, which are independent copies of the main repository. They propose changes through pull requests, allowing maintainers to review the changes before merging them into the main codebase.

    Distributed Nature:

    Git's distributed architecture allows developers to work independently on their local repositories, even without an internet connection. This decentralization and redundancy provide flexibility and resilience to the version control system.

In summary, Git works by creating a local repository on each developer's machine, where they can make changes, stage those changes, and commit them to the version history. Developers can create branches for new features or bug fixes and merge changes between branches. Collaboration occurs through remote repositories, where developers can push and pull changes to synchronize their work with others. Git's distributed nature and powerful branching and merging capabilities have made it an essential tool for modern software development.


----------------------------------------------------------------------------------------------------------------------
• Working with Bitbucket
----------------------------------------------------------------------------------------------------------------------
	Create a bitbucket account 
	Create a repo.
	or import a public repo from my account
----------------------------------------------------------------------------------------------------------------------
	Create a repo.
----------------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------------
	Clone the repo.
----------------------------------------------------------------------------------------------------------------------
	Copy clone command from top right - for e.g. 
		git clone https://vilastes1-admin@bitbucket.org/vilastes1/docker-k8s.git
		
	This pop up's a new small window. Grant access in it.
	
----------------------------------------------------------------------------------------------------------------------
	Make changes to remote repo.
----------------------------------------------------------------------------------------------------------------------
	Directly from the browser

----------------------------------------------------------------------------------------------------------------------
	Make local changes
----------------------------------------------------------------------------------------------------------------------

	
----------------------------------------------------------------------------------------------------------------------
		git add
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
		git commit
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
		git push
----------------------------------------------------------------------------------------------------------------------
https://www.youtube.com/watch?v=qjUkCwmdaDo
https://www.srcmake.com/home/bitbucket-pr

----------------------------------------------------------------------------------------------------------------------
		create a pull request
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
		approve pull request	
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------




Rest can be found in 
D:\PraiseTheLord\HSBGInfotech\Others\vilas\aws\cloudformation

More ref. 
	https://medium.com/@venkatsatyanreddy_92646/beginners-guide-to-jenkins-pipelines-16a6181def97
	https://www.lambdatest.com/blog/jenkins-pipeline-tutorial/
	https://www.tpointtech.com/jenkins-setup-build-jobs
	https://spacelift.io/blog/what-is-jenkins
	https://github.com/allcloud-io/jenkins-pipeline-tutorial/blob/master/README.md
	https://www.jenkins.io/doc/tutorials/using-jenkinsfile-runner-github-action-to-build-jenkins-pipeline/

Excellent 	
	https://github.com/ssbostan/jenkins-tutorial
	
	https://github.com/jenkinsci/pipeline-examples
	
webhook 	
https://www.cprime.com/resources/blog/how-to-integrate-jenkins-github/	